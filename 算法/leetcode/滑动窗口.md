# 3.无重复字符的最长子串

题目：

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

## （1）暴力（超时）

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        l = len(s)
        if(l == 0):
            return 0
        maxLen = 0;
        for i in range(l):
            j = i+1
            while(j < l):
                set1 = set(s[i:j+1])
                if(len(set1) == j-i+1):
                    if(maxLen<(j-i+1)):
                        maxLen = j-i+1
                j+=1
        if(maxLen==0):
            return 1
        return maxLen
```

## (2)滑动窗口

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        i  = 0;j = i
        l = len(s)
        set1 = set()
        maxLen = 0
        while(i < l and j < l):
            if(s[j] not in set1):
                set1.add(s[j])
                j+=1
                maxLen = max(maxLen,j-i)
            else:
                set1.remove(s[i])
                i+=1
        return maxLen
```

# 30.串联所有单子的子串(滑动窗口+字典)

题目：

```python
输入：
  s = "wordgoodgoodgoodbestword",
  words = ["word","good","best","word"]
输出：[]
输入：
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出：[0,9]
```

因为words中的每个单词长度都是统一的，所以可以用滑动窗口来解决。在窗口内部，可按顺序检测每个固定长度的单词是否在words中。因为words中的单词是可以重复的，所以需要用一个字典来统计每个单词出现的频率。

下面是错误的代码：只考虑的滑动窗口，没有加字典。

```python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if(s=="" or words==[]):
            return []
        n = len(words)
        l = len(words[0])
        window = n*l
        i = 0
        l2 = len(s)
        ans = []
        while(i <= l2-window+1):
            import numpy
            exist = numpy.zeros(n)
            subWords  = s[i:i+window]
            for j in range(n):
                if(subWords[j*l:(j+1)*l] in words):
                    exist[words.index(subWords[j*l:(j+1)*l])]=1
            if(exist.sum() == n):
                ans.append(i)
            i += 1
        return ans
                    
```

下面的代码考虑了滑动窗口和字典，但没有及时剪枝。代码正确代码但超时。。。

```python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if(s=="" or words==[]):
            return []
        n = len(words)
        l = len(words[0])
        d = collections.defaultdict(int)
        for value in words:
            d[value] += 1
        window = n*l
        i = 0
        l2 = len(s)
        ans = []
        while(i <= l2-window+1):
            import numpy
            exist = collections.defaultdict(int)
            subWords  = s[i:i+window]
            for j in range(n):
                if(subWords[j*l:(j+1)*l] in words):
                    exist[subWords[j*l:(j+1)*l]]+=1       
            if(exist==d):
                ans.append(i)
            i += 1
        return ans
                    
```

最终正确的代码(在上面代码基础上加一句break)：

```python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if(s=="" or words==[]):
            return []
        n = len(words)
        l = len(words[0])
        d = collections.defaultdict(int)
        for value in words:
            d[value] += 1
        window = n*l
        i = 0
        l2 = len(s)
        ans = []
        while(i <= l2-window+1):
            import numpy
            exist = collections.defaultdict(int)
            subWords  = s[i:i+window]
            for j in range(n):
                if(subWords[j*l:(j+1)*l] in words):
                    exist[subWords[j*l:(j+1)*l]]+=1
                else:
                		break
            if(exist==d):
                ans.append(i)
            i += 1
        return ans
                    
```

