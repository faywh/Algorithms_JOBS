[TOC]

# 十大排序算法

@Author: Howard Wonanut

@Date: 2019-10

> 参考：
>
> 综合 https://github.com/wonanut/JS-Sorting-Algorithm
>
> 综合 https://github.com/wonanut/interview/tree/master/Algorithm
>
> 快排 https://blog.csdn.net/qq_20011607/article/details/82357239



## 0 前言

排序算法是算法中的基础，这里我总结并实现了常见的十种排序算法。对于每一种算法，首先阐述其原理，然后分别使用Python和C++对其进行实现。**前七种排序算法应该做到烂熟于心！**

排序算法可以分为内部排序和外部排序，内部排序的过程中数据一直在内存中；而外部排序在排序的过程中有部分数据需要存储在外存中，因此在排序的过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序和基数排序等。各算法的时间复杂度、稳定性等内容概括如下。

![十大经典排序算法 概览截图](https://raw.githubusercontent.com/wonanut/Algorithms_JOBS/master/%E7%AE%97%E6%B3%95/imgs/sort.png)

[图片来源]: https://github.com/wonanut/JS-Sorting-Algorithm



### 0.1 时间复杂度

- 正所谓天下没有免费的午餐，那些简单的排序算法其时间复杂度往往也较高，比如插入排序、选择排序和冒泡排序这几个最基本的排序算法其平均时间复杂度均在$O(n^2)$，其中冒泡和插入排序算法在最好的情况下（原数据本身有序）时间复杂度为$O(n)$；
- 除此之外常规的排序算法（希尔排序，归并排序，堆排序和快速排序）的平均时间复杂度均为$O(n\log{n})$；
- 其他三种排序算法的时间复杂度一般不予讨论，了解即可。



### 0.2 算法稳定性

算法的**稳定性指的是：在排序完成之后，原本相等的两个值其相对位置（前后顺序）没有变化**，算法的稳定性由算法本身排序思路所决定。前七种排序算法中，冒泡排序、插入排序和归并排序是稳定的。



## 1 选择排序

`不稳定排序算法`

选择排序的思路很直接：每次从未排序的序列中选出一个最小（大）的数字，并将该数字追加在已经排好序的序列的最后（前）面即可。

#### 动画演示

![动图演示](https://raw.githubusercontent.com/wonanut/Algorithms_JOBS/master/%E7%AE%97%E6%B3%95/imgs/selectionSort.gif)

因为该算法每一轮都需要遍历所有的未排好序的序列一次，因此无论原始序列是否有序，该算法的时间复杂度均为$O(n^2)$，其空间复杂度为$O(1)$。

其Python实现代码为：

```python
def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[j]
    return arr
```



## 2 冒泡排序

`稳定排序算法`

冒泡排序的过程很像气泡从一个方向往另一个方向运动的过程。以从前往后冒泡，进行增序排列，其算法步骤为：

1. 从最左边开始，比较相邻的元素，如果左边的数大于右边的数，则交换他们两个；
2. 对每一对相邻的元素做同样的工作，直至最右边的边界。因此这一步完成之后，未排序序列最右边的数字就是最大的数，如此将最右边的数添加到已排序的数组最左边（未排序序列右边界往左移动一位）；
3. 继续上述操作，直至未排序数组为空。

### 动画演示

![动图演示](https://raw.githubusercontent.com/wonanut/Algorithms_JOBS/master/%E7%AE%97%E6%B3%95/imgs/bubbleSort.gif)

最基本的冒泡排序Python实现代码为：

```python
def bubble_sort(arr):
    for i in range(len(arr) - 1):
        for j in range(len(arr) - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```

如果使用上述代码，即使原序列是有序的，每一次冒泡的过程仍需要正常进行一遍，因此其时间复杂度一直为$O(n^2)$ 。一般的，我们还会对冒泡排序进行优化，当对序列完成一遍冒泡之后发现序列中没有发生交换（也就是序列已经有序），这个时候就可以提前结束排序了，其Python代码如下所示:

```python
def bubble_sort(arr):
    for i in range(len(arr) - 1):
        flag = True
        for j in range(len(arr) - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                flag = False
       	if flag:
            break
    return arr
```

如此一来，当原始序列有序或者接近有序的时候，冒泡排序算法的时间复杂度将会接近于$O(n)$.



## 3 插入排序

`稳定排序算法`

作为“简单排序算法三剑客里”的最后一个，插入排序算法的思路也比较好懂。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。其算法步骤为：

1. 初始时刻，将序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面）。

### 动画演示

![动图演示](https://raw.githubusercontent.com/wonanut/Algorithms_JOBS/master/%E7%AE%97%E6%B3%95/imgs/insertionSort.gif)

Python实现代码：

```python
def insert_sort(arr):
    for i in range(len(arr)):
        temp = arr[i]
        pre_index = i - 1
        while pre_index >= 0 and arr[pre_index] > temp:
            arr[pre_index + 1] = arr[pre_index]
            pre_index -= 1
        arr[pre_index + 1] = temp
    return arr
```



## 4 希尔排序

`不稳定排序算法`

希尔排序也称**递减增量排序**算法，是插入排序的一种更高级的改进版本，不过希尔排序是非稳定排序算法。

希尔排序是利用了插入排序的特性：

- 插入排序在对几乎已经排好序的数据进行操作时，效率高，即可以达到线性排序的效率
- 但是插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序的基本思路是：先将整个待排序的序列分割成若干个子序列分别进行直接插入排序（也就是说，shell排序的每一趟都是直接插入排序）；待整个序列中的数据都“基本有序”时，再对整个序列进行一次直接插入排序。

Python实现代码

```python
def shell_sort(arr):
    gap = 1
    while gap < len(arr) / 3:
    	gap = gap * 3 + 1
    while gap > 0:
        for i in range(gap, len(arr)):
            j = i - gap
            temp = arr[i]
            while j >= 0 and arr[j] > temp:
                arr[j + gap] = arr[j]
                j -= gap
            arr[j + gap] = temp
        gap = gap // 3
    return arr
```



## 5 归并排序

`稳定排序算法`

归并排序是建立在归并操作上的一种有效的排序算法，作为一种典型的分而治之思想的算法，归并排序有两种实现方法（其算法思想都是一样的，只不过实现起来有区别）：

- 自上而下的递归（所有的递归方法都可以使用迭代实现，所以有第二种方法）
- 自下而上的迭代



### 动画演示

![动图演示](https://raw.githubusercontent.com/wonanut/Algorithms_JOBS/master/%E7%AE%97%E6%B3%95/imgs/mergeSort.gif)

Python实现代码

```python
def merge_sort(array):
    def merge(arr1, arr2):
        ans = []
        while arr1 and arr2:
            if arr1[0] < arr2[0]:
                ans.append(arr1.pop(0))
            else:
                ans.append(arr2.pop(0))
        while arr1:
            ans.append(arr1.pop(0))
        while arr2:
            ans.append(arr2.pop(0))
        return ans
    
    def partition(arr):
        if len(arr) < 2:
            return arr
        mid = len(arr) // 2
        l = partition(arr[0:mid])
        r = partition(arr[mid:])
        return merge(l, r)
    
    return partition(array)
```



## 6 快速排序

快速排序通常明显比其他的$O(\log{n})$复杂度的排序算法更快。快排是分而治之思想在排序算法上的典型应用，其使用分治策略来将一个待排序序列分成两个子序列，在子序列上继续执行这个操作。

快速排序的最坏时间复杂度是$O(n^2)$，比如对已经有序的序列进行快排；其平均时间复杂度是$O(\log{n})$。

### 算法步骤

1. 从数列中挑出一个元素，称为“基准”（pivot）；
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地把小于基准值的子序列和大于基准值的子序列排序。

### 动图演示

![动图演示](https://raw.githubusercontent.com/wonanut/Algorithms_JOBS/master/%E7%AE%97%E6%B3%95/imgs/quickSort.gif)

### 代码实现

快速排序有多种实现方式，这里总结三种快排代码。

#### 实现1 快慢双指针（上面的动图演示的是这种实现）

定义指针ptr，ptr指针左边的数都比pivot小，ptr指针右边的数都比pivot大，快指针即i从左往右遍历，遇到arr[i]小于ptr的则将arr[i]的值与arr[++ptr]的值调换，直至i到达序列末端。

```python
def quick_sort(arr):
    def _partition(arr, left, right):
        pivot = arr[left]
        ptr = left
        for i in range(left + 1, right):
            if arr[i] < pivot:
                ptr += 1
                arr[ptr], arr[i] = arr[i], arr[ptr]
        arr[left], arr[ptr] = arr[ptr], arr[left]
       	return ptr
        
    def _quick_sort(arr, left, right):
        if left >= right:
            return
        p = _partition(arr, left, right)
        _quick_sort(arr, left, p)
        _quick_sort(arr, p + 1, right)
        
    return _quick_sort(arr, 0, len(arr))
```

#### 实现2 前后双指针

左边的指针从左往右，右边的指针从右往左

```python
def quick_sort(arr):
    def _partition(arr, left, right):
        pivot = arr[left]
        lptr, rptr = left + 1, right - 1
        while True:
            while lptr <= rptr and arr[lptr] <= pivot:
                lptr += 1
            while lptr <= rptr and arr[rptr] >= pivot:
                rptr -= 1
            if lptr > rptr:
                break
            arr[lptr], arr[rptr] = arr[rptr], arr[lptr]
            lptr, rptr = lptr + 1, rptr - 1
        arr[left], arr[rptr] = arr[rptr], arr[left]
        return rptr
        
    def _quick_sort(arr, left, right):
        if left >= right:
            return
       	p = _partition(arr, left, right)
        _quick_sort(arr, left, p)
        _quick_sort(arr, p + 1, right)
        
    return _quick_sort(arr, 0, len(arr))
```

#### 实现3 三路快排

三路快排，是对双指针快排算法的优化版本，主要考虑到待排序序列中可能有多个重复值，使得算法效率下降。使用lt和gt指针隔开，其中[left,lt)区间的数小于pivot，[gt,right)区间的数大于pivot，[lt,gt)区间里的数不清楚其大小。在排序结束后[lt,gt)区间里的数等于pivot，从而在接下来划分区间的时候直接忽略这些重复数字，从而加快排序效率。

```python
def quick_sort(arr):
    def _quick_sort(arr, left, right):
        if left >= right:
            return
        pivot = arr[left]
        lt, gt, ptr = left, right + 1, left + 1
        while ptr < gt:
            if arr[ptr] < pivot:
                arr[lt + 1], arr[ptr] = arr[ptr], arr[lt + 1]
               	ptr += 1
                lt += 1
            elif arr[ptr] > pivot:
                arr[gt - 1], arr[ptr] = arr[ptr], arr[gt - 1]
            else:
                ptr += 1
        arr[left], arr[lt] = arr[lt], arr[left]
        lt -= 1
        
        _quick_sort(arr, left, lt)
        _quick_sort(arr, gt, right)
        
    _quick_sort(arr, 0, len(arr) - 1)
    return arr
```





## 7 堆排序



## 8 计数排序*

## 9 桶排序*

## 10 基数排序*  